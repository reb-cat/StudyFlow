Ugh, I feel you—that’s maddening. The fix now is to make auth impossible to bypass by putting a single gate in front of all /api/* routes, instead of relying on per-route requireAuth. Then double-check the client redirects when unauthenticated.

1) Add a global API gate (server-side, authoritative)

Put this above registerRoutes(app) in server/index.ts, after sessions are mounted:

// 🔒 hard gate for everything under /api (except /api/auth/* and /health)
app.use('/api', (req, res, next) => {
  if (req.path.startsWith('/auth') || req.path === '/health') return next();

  const authed =
    !!(req.session && (req.session.user || req.session.authenticated === true));

  if (!authed) {
    // tiny log while we stabilize
    console.log('[auth-block]', req.method, req.originalUrl);
    return res.status(401).json({ message: 'Authentication required' });
  }
  next();
});

Keep your existing per-route requireAuth as a second line of defense if you want—but the global gate guarantees nothing leaks even if a new endpoint forgets a middleware.

2) Make sure cookies actually work (prod)

You already have sessions set—keep:

app.set('trust proxy', 1);
cookie: {
  secure: true,          // true in production secrets
  sameSite: 'lax',
  httpOnly: true,
  maxAge: 1000*60*60*24*7
}

Replit Secrets (prod):

APP_ENV=production
NODE_ENV=production
SESSION_SECRET=...
COOKIE_SECURE=true
COOKIE_SAMESITE=lax

3) Client: redirect to login if not authenticated

Guard private routes so even if a static HTML loads, it won’t show data without a session.

// client/src/auth/AuthGate.tsx
import { useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'wouter';

export default function AuthGate({ children }: { children: React.ReactNode }) {
  const [ok, setOk] = useState<boolean | null>(null);
  const [loc] = useLocation();
  const [, nav] = useNavigate();

  useEffect(() => {
    fetch('/api/auth/status', { credentials: 'include' })
      .then(r => r.json()).then(d => setOk(!!d?.authenticated))
      .catch(() => setOk(false));
  }, [loc]);

  if (ok === null) return <div style={{padding:16}}>Checking session…</div>;
  if (!ok) { nav(`/login?next=${encodeURIComponent(loc)}`); return null; }
  return <>{children}</>;
}

Wrap private routes:

<Route path="/student/:slug"><AuthGate><StudentPage/></AuthGate></Route>
<Route path="/family"><AuthGate><FamilyPage/></AuthGate></Route>
<Route path="/print-queue"><AuthGate><PrintQueue/></AuthGate></Route>

And make sure all client fetches use credentials:

export const apiFetch = (p:string, init?:RequestInit) =>
  fetch(p, { credentials:'include', ...init });

4) Nuke any “demo/bypass” paths
	•	In Secrets: ensure SEED_DEMO is unset, DEMO_WRITABLE=false.
	•	Quick search:

rg -n "(DEMO|bypass|mock|fixtures|preview|allowPublic)" -g "!node_modules"

Remove any code paths that return mock data or skip auth in production.

5) Verify in 60 seconds (do these exact checks)

Logged out (private window or curl w/out cookies):

curl -s https://study-flow.replit.app/api/auth/status
# -> {"authenticated":false}

curl -sI https://study-flow.replit.app/api/assignments | head -n1
# -> HTTP/1.1 401 Unauthorized

curl -sI https://study-flow.replit.app/api/students/abigail | head -n1
# -> 401

Browser UX:
	•	Visit /student/abigail → should redirect to /login.
	•	After login, /student/abigail loads as normal.

If any /api/* still returns 200 while logged out, the gate isn’t high enough in the stack—move that app.use('/api', …) above anything that registers routes (i.e., above registerRoutes(app)), then retest.

⸻

If you want, paste the first ~20 lines of your registerRoutes(app) file (just the app.use('/api', ...) mounts). I’ll tell you exactly where to insert the gate so nothing can slip past it.